<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>Panda Poop Flappy</title>
    <style>
        body {
            margin: 0;
            background: #87ceeb;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            overflow: hidden;
        }
        
        canvas {
            background: linear-gradient(#cceeff, #e6f7ff);
            border: 3px solid #222;
            /* display will be sized via JS to keep internal frame (400x600) unchanged */
            width: 400px;
            /* fallback before JS runs */
            height: 600px;
            /* fallback before JS runs */
            touch-action: manipulation;
            /* improve touch responsiveness */
        }
        
        #restartBtn {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 28px;
            font-size: 18px;
            background: #222;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: none;
            z-index: 10;
        }
    </style>
</head>

<body>

    <canvas id="game" width="400" height="600"></canvas>
    <button id="restartBtn">Restart</button>

    <script>
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const restartBtn = document.getElementById("restartBtn");

        // Keep a fixed internal game size (do NOT change these).
        const GAME_W = 400;
        const GAME_H = 600;

        /* ---------- GAME STATE ---------- */
        let panda, pipes, poops, splats, frame, gameOver, score;

        const gravity = 0.45;
        const jumpPower = -8;

        /* ---------- AUDIO ---------- */
        const audioCtx = new(window.AudioContext || window.webkitAudioContext)();
        let audioUnlocked = false;

        function unlockAudio() {
            if (audioUnlocked) return;
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    audioUnlocked = true;
                });
            } else {
                audioUnlocked = true;
            }
            // remove the first-interaction listeners once unlocked
            document.removeEventListener('pointerdown', unlockAudio);
            document.removeEventListener('touchstart', unlockAudio);
        }

        function fartSound() {
            if (!audioUnlocked) return;
            // Simple fart sound using oscillator
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(90, audioCtx.currentTime);
            o.frequency.linearRampToValueAtTime(40, audioCtx.currentTime + 0.18);
            g.gain.setValueAtTime(0.18, audioCtx.currentTime);
            g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.18);
            o.connect(g).connect(audioCtx.destination);
            o.start();
            o.stop(audioCtx.currentTime + 0.18);
        }

        // Ensure mobile/responsive display: scale the CSS size of the canvas
        function resizeCanvasStyle() {
            // compute a scale that fits within the viewport while preserving aspect ratio
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const scale = Math.min((vw * 0.95) / GAME_W, (vh * 0.9) / GAME_H);
            const displayW = Math.round(GAME_W * Math.max(0.4, scale));
            const displayH = Math.round(GAME_H * Math.max(0.4, scale));
            canvas.style.width = displayW + 'px';
            canvas.style.height = displayH + 'px';
        }

        // attach resize handler
        window.addEventListener('resize', resizeCanvasStyle);

        /* ---------- INIT ---------- */
        function init() {
            panda = {
                x: 100,
                y: 260,
                v: 0
            };
            pipes = [];
            poops = [];
            splats = [];
            frame = 0;
            score = 0;
            gameOver = false;
            restartBtn.style.display = "none";

            // ensure canvas is displayed correctly on start
            resizeCanvasStyle();
        }
        init();

        /* ---------- INPUT ---------- */
        function dropPoop() {
            fartSound();
            poops.push({
                x: panda.x - 10,
                y: panda.y + 35,
                v: 2
            });
        }

        function jump() {
            if (gameOver) return;
            panda.v = jumpPower;
            dropPoop();
        }

        // unlock audio on first user interaction (required on many mobile browsers)
        document.addEventListener('pointerdown', unlockAudio, {
            once: true
        });
        document.addEventListener('touchstart', unlockAudio, {
            once: true
        });

        document.addEventListener("keydown", e => {
            if (e.code === "Space") jump();
        });

        canvas.addEventListener("click", jump);

        // Touch controls:
        // - single-finger tap => jump
        // - multi-finger (2+) touch => dropPoop
        canvas.addEventListener('touchstart', e => {
            // prevent scrolling/zooming while interacting with the game
            e.preventDefault();
            if (gameOver) return;
            if (e.touches && e.touches.length > 1) {
                dropPoop();
            } else {
                jump();
            }
        }, {
            passive: false
        });

        // Right click = extra poop ðŸ’© (desktop)
        canvas.addEventListener("contextmenu", e => {
            e.preventDefault();
            if (!gameOver) dropPoop();
        });

        /* ---------- RESTART ---------- */
        restartBtn.onclick = () => {
            init();
            update();
        };

        /* ---------- PIPES ---------- */
        function createPipe() {
            let gap = 190;
            let top = Math.random() * 220 + 40;
            pipes.push({
                x: canvas.width,
                top,
                bottom: canvas.height - top - gap,
                passed: false
            });
        }

        /* ---------- DRAW PANDA ---------- */
        function drawPanda() {
            ctx.save();
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.ellipse(panda.x, panda.y, 22, 26, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#f2f2f2";
            ctx.beginPath();
            ctx.ellipse(panda.x, panda.y + 8, 12, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(panda.x - 16, panda.y - 22, 8, 0, Math.PI * 2);
            ctx.arc(panda.x + 16, panda.y - 22, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.ellipse(panda.x - 8, panda.y - 6, 6, 8, 0, 0, Math.PI * 2);
            ctx.ellipse(panda.x + 8, panda.y - 6, 6, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(panda.x - 8, panda.y - 6, 2, 0, Math.PI * 2);
            ctx.arc(panda.x + 8, panda.y - 6, 2, 0, Math.PI * 2);
            ctx.fill();

            // Draw poop if dropping (show a poop under panda if recently dropped)
            if (poops.length > 0) {
                const lastPoop = poops[poops.length - 1];
                if (lastPoop && Math.abs(lastPoop.x - (panda.x - 10)) < 5 && Math.abs(lastPoop.y - (panda.y + 35)) < 20) {
                    ctx.fillStyle = "#6b3e26";
                    ctx.beginPath();
                    ctx.arc(panda.x, panda.y + 35, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        /* ---------- POOP + BONUS ---------- */
        function drawPoop() {
            ctx.fillStyle = "#6b3e26";

            poops.forEach(p => {
                p.v += 0.25;
                p.y += p.v;

                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fill();

                pipes.forEach(pipe => {
                    if (!pipe.bonus &&
                        p.x > pipe.x &&
                        p.x < pipe.x + 50 &&
                        p.y > pipe.top &&
                        p.y < canvas.height - pipe.bottom
                    ) {
                        score += 2; // ðŸ’¥ bonus
                        pipe.bonus = true;
                    }
                });

                if (p.y > canvas.height - 20) {
                    for (let i = 0; i < 6; i++) {
                        splats.push({
                            x: p.x,
                            y: canvas.height - 20,
                            vx: (Math.random() - 0.5) * 3,
                            vy: Math.random() * -3,
                            life: 30
                        });
                    }
                    p.dead = true;
                }
            });

            poops = poops.filter(p => !p.dead);
        }

        function drawSplatter() {
            ctx.fillStyle = "#5a2e1a";
            splats.forEach(s => {
                s.x += s.vx;
                s.y += s.vy;
                s.vy += 0.15;
                s.life--;
                ctx.beginPath();
                ctx.arc(s.x, s.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            splats = splats.filter(s => s.life > 0);
        }

        /* ---------- PIPES ---------- */
        function drawPipes() {
            ctx.fillStyle = "#228B22";
            pipes.forEach(p => {
                ctx.fillRect(p.x, 0, 50, p.top);
                ctx.fillRect(p.x, canvas.height - p.bottom, 50, p.bottom);
            });
        }

        function collision(p) {
            return (
                panda.x + 20 > p.x &&
                panda.x - 20 < p.x + 50 &&
                (panda.y - 25 < p.top ||
                    panda.y + 25 > canvas.height - p.bottom)
            );
        }

        /* ---------- GAME LOOP ---------- */
        function update() {
            if (gameOver) {
                ctx.fillStyle = "#000";
                ctx.font = "28px Arial";
                ctx.fillText("Game Over ðŸ’€", 110, 260);
                restartBtn.style.display = "block";
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            panda.v += gravity;
            panda.y += panda.v;

            if (panda.y < 0 || panda.y > canvas.height) gameOver = true;

            if (frame % 150 === 0) createPipe();

            pipes.forEach(p => {
                p.x -= 1.8;

                if (!p.passed && p.x + 50 < panda.x) {
                    score += 1; // âœ… passed pipe
                    p.passed = true;
                }

                if (collision(p)) gameOver = true;
            });

            pipes = pipes.filter(p => p.x + 50 > 0);

            drawPoop();
            drawSplatter();
            drawPanda();
            drawPipes();

            ctx.fillStyle = "#000";
            ctx.font = "20px Arial";
            ctx.fillText("Score: " + score, 10, 30);

            frame++;
            requestAnimationFrame(update);
        }

        update();
    </script>

</body>

</html>